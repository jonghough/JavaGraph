package jgh.javagraph.algorithms;

import jgh.javagraph.*;

import java.util.*;

/**
 * Implementation of AStar algorithm for a weighted, undirected graph.
 */
public class AStar {

    /**
     * Returns the ordered list of nodes between the start node, and end node, which is the
     * minimum path, generated by the A-star algorithm with heuristic <code>IAStarHeuristic</code>.
     *
     * @param graph     The graph
     * @param nodeS     The start node
     * @param nodeF     The final, goal node
     * @param heuristic The heuristic function for a measure of distance.
     * @param <E>       Weighted edge type
     * @return minimum path list.
     */
    public static <N, E extends WeightedEdge<N>> ArrayList<N> findMinPath(Graph<N, E> graph, N nodeS, N nodeF, IAStarHeuristic heuristic) {

        // Instantiate the openSet and closedSet. The openSet is the collection
        // of currently searchable nodes. Closed Set is the collection of already
        // finished nodes, that should no longer be searched.
        HashSet<N> openSet = new HashSet<N>();
        HashSet<N> closedSet = new HashSet<N>();
        openSet.add(nodeS);
        ArrayList<N> shortestPath = new ArrayList<N>();

        // Instantiate the score maps. THe give the currently evaluated g-distance,
        // and f-distance, where g-distance is distance from source node to current node,
        // f-distance is the estimated distance g-distance + heuristic, where the heuristic
        // is the estimated distance to the end node from the current node.
        HashMap<N, Float> gScoreMap = new HashMap<N, Float>();
        HashMap<N, Float> fScoreMap = new HashMap<N, Float>();


        HashMap<N,NodeData<N>> nodeMap = new HashMap<N,NodeData<N>>();

        // Initialize the score maps.
        for (N t : graph.getNodes()) {
            NodeData<N> nodeData = new NodeData<N>(t);
            if(t.equals(nodeS)){
                gScoreMap.put(t, 0f);
                fScoreMap.put(t, 0f + heuristic.getHeuristic(nodeS, nodeF));
            }
            else {
                gScoreMap.put(t, Float.MAX_VALUE);

                fScoreMap.put(t, 0f);
            }
            nodeData.setPrevious(Optional.of(t));
            nodeMap.put(t, nodeData);
        }

        //begin the search.
        while (openSet.size() > 0) {
            N current = null;
            for (N openNode : openSet) {
                if (current == null)
                    current = openNode;
                else {
                    if (fScoreMap.get(current) > fScoreMap.get(openNode)) {
                        current = openNode;
                    }
                }
            }

            if (current == nodeF) {
                shortestPath.add(current);
                break;
            }

            openSet.remove(current);
            closedSet.add(current);
            //get adjacent node list.
            Collection<E> incident = Utilities.getIncidentEdges(graph.getEdges(), current);
            for (E u : incident) {
                for (N t : u.nodes()) {
                    if (t == current)
                        continue;
                    else if (closedSet.contains((t)))
                        continue;
                    else {
                        float tmp = gScoreMap.get(current) + u.getWeight();// g + h sum.
                        if (openSet.contains(t) == false) {

                            nodeMap.get(t).setPrevious(Optional.of(current));
                            openSet.add(t);
                            gScoreMap.put(t, tmp);
                            fScoreMap.put(t, tmp + heuristic.getHeuristic(t, nodeF));
                            nodeMap.get(t).setDistance(tmp);
                        } else {
                            float currentScore = gScoreMap.get(t);
                            if (currentScore > tmp) {
                                nodeMap.get(t).setPrevious(Optional.of(current));
                                gScoreMap.put(t, tmp);
                                fScoreMap.put(t, tmp + heuristic.getHeuristic(t, nodeF));
                                nodeMap.get(t).setDistance(tmp);
                            }
                        }
                    }
                }
            }
        }


        N p = (N)nodeMap.get(nodeF).getPrevious().get();
        while (p != null && p != nodeMap.get(p).getPrevious().get()) {
            shortestPath.add(p);
            p = (N)nodeMap.get(p).getPrevious().get();
        }
        shortestPath.add(nodeS);
        Collections.reverse(shortestPath);
        return shortestPath;
    }


    /**
     * Heuristic distance estimate for each pair of nodes in the graph. Necessary
     * for <i>A Star</i> algorithm, to giv some initial guess at the distances.
     */
    public interface IAStarHeuristic<N> {

        /**
         * Returns the heuristic measure f distance between a given <code>INode</code>, <code>t</code>, and the
         * goal <code>INode</code>. This is necessary in the implementation of the <b>AStar</b> algorithm.
         *
         * @param t    node
         * @param goal the goal node
         * @return A heuristic distance estimate.
         */
        float getHeuristic(N t, N goal);
    }
}
